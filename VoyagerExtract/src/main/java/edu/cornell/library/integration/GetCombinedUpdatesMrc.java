package edu.cornell.library.integration;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import edu.cornell.library.integration.bo.BibData;
import edu.cornell.library.integration.bo.MfhdData;
import edu.cornell.library.integration.ilcommons.configuration.VoyagerToSolrConfiguration;
import edu.cornell.library.integration.ilcommons.service.DavServiceFactory;

/**
 * This gets a list of BIB and MFHD records updates from the Voyager database for a
 * given period of time and then saves the MARC for these records to a WEBDAV directory.  
 * 
 * This list is combined with the list of BIB records that have had their MHFD 
 * records deleted which is generated by IdentifyDeletedRecords.
 * 
 * Once the list of the IDs of BIB and MFHD records that are needed is gathered,
 * the Voyager database is queries to get the MARC.  That data is saved to a 
 * sequence of files.
 */
public class GetCombinedUpdatesMrc extends VoyagerToSolrStep {
   
   protected final Log logger = LogFactory.getLog(getClass());
   
   protected static Integer reportPeriod = 1; //days
   
   /**
    * default constructor
    */
   public GetCombinedUpdatesMrc() { 
       
   }     

   /**
    * Main is called with the normal VoyagerToSolrConfiguration args.
    */
   public static void main(String[] args) throws Exception {                
     GetCombinedUpdatesMrc app = new GetCombinedUpdatesMrc();
     app.getCombinedUpatedsAndSaveAsMARC( VoyagerToSolrConfiguration.loadConfig(args ), reportPeriod);     
   }
   
   
	public void getCombinedUpatedsAndSaveAsMARC(VoyagerToSolrConfiguration config, Integer reportPeriod) 
	        throws Exception{

		if ( getCatalogService() == null )
		    throw new Exception("Could not get catalogService");			
		
		setDavService(DavServiceFactory.getDavService( config ));
                  	     	                 		
		String toDate = midnightThisMorning();
		String fromDate = daysEarlier(reportPeriod);		
 
		System.out.println("fromDate: "+ fromDate);
        System.out.println("toDate: "+ toDate);        
				        
		// get BIB and MFHD ID of records updated in the report period        
        Set<String> updatedBibIds = getUpdatedBibIdsFromCatalog( fromDate, toDate );        
        Set<String> updatedMfhdIds = getUpdatedMfhdIdsFromCatalog( fromDate, toDate);		
		
        // Get additional BIB IDs for changed MFHD records 
		System.out.println("Adding extra BIB IDs that need to be updated beacause "
		        + "their MFHD records changed");				
		updatedBibIds.addAll(getBibIdsWhoseMfhdsChanged( updatedMfhdIds ));
			
		// Get additional BIB IDs that have been added or have deleted MFHDs from step 2
		String date =  getDateString(Calendar.getInstance());
		List<String> bibListForUpdate = getBibIdsWithDeletedMfhd( config, date );
	    System.out.println("bibListForUpdate: " + bibListForUpdate.size() + " (from deleted and suppressed mfhds)");
	    updatedBibIds.addAll( bibListForUpdate );
		List<String> bibListForAdd = getBibIdsToAdd( config, date );
	    System.out.println("bibListForAdd: " + bibListForAdd.size() + " (from new or unsuppressed bibs)");
	    updatedBibIds.addAll( bibListForAdd );
	     	    
	    // Get MFHD IDs for all the BIB IDs
		System.out.println("Adding extra holdings ids");		
		updatedMfhdIds.addAll( getHoldingsForBibs( updatedBibIds ) );
		
		System.out.println("Total BibIDList: " + updatedBibIds.size());
		System.out.println("Total MfhdIDList: " + updatedMfhdIds.size());

		saveBIBsToMARC(  updatedBibIds , config.getWebdavBaseUrl() + "/" + config.getDailyMrcDir() );
		saveMFHDsToMARC( updatedMfhdIds, config.getWebdavBaseUrl() + "/" + config.getDailyMfhdDir() );
	}

	/**
	 * Given a set of IDs of MFHD records that have changed, return a set of BIB IDs 
	 * that are associated with those MFHD records. These BIB records will need to be
	 * updated so the Sorl index will reflect the new MFHD records. 
	 * @param updatedMfhdIds - MFHD IDs of records that have changed  
	 */
	 private Set<String> getBibIdsWhoseMfhdsChanged( Collection<String> updatedMfhdIds  ) 
	         throws Exception {	     
	     try {
	         Set<String> extraBibIds = new HashSet<String>();
	         for (String mfhdid : updatedMfhdIds) {            
                extraBibIds.addAll( getCatalogService().getBibIdsByMfhdId(mfhdid) );
            }
            System.out.println("BIB IDs added due to MFHD updates "
                    + "(extraBibIds): " + extraBibIds.size());        
            return extraBibIds;
         } catch (Exception e) {
             throw new Exception("Problem while getting BIB IDs for "
                     + "MFHDs from catalog", e);
         }
    }


    /**
     * Get the MARC for each MFHD ID and concatenate data to create MARC files. 
     * Only put 10000 MARC records in a file.
     */
	private void saveMFHDsToMARC(Set<String> updatedMfhdIds, String mfhdDestDir) throws Exception {
	    int recno = 0;
        int maxrec = 10000;
        int seqno = 1;
        StringBuffer sb = new StringBuffer();                        
        
        Iterator<String> mfhdIds = updatedMfhdIds.iterator();
        while( mfhdIds.hasNext() ){
            String mfhdid = mfhdIds.next();
            
            List<MfhdData> mfhdDataList;
            try {
                mfhdDataList = getCatalogService().getMfhdData(mfhdid);
            } catch (Exception e) { 
                throw new Exception("Could not get MARC for MFHD ID " + mfhdid, e );
            } 
            
            for (MfhdData mfhdData : mfhdDataList) { 
                sb.append(mfhdData.getRecord()); 
            }
            /* Inserting a carriage return after each MARC record in the file.
             * This is not valid in a technically correct MARC "database" file, but
             * is supported by org.marc4j.MarcPermissiveStreamReader. If we ever stop using this
             * library, we may need to remove this. For now, it simplifies pulling problem
             * records from the MARC "database".
             */
            if (! mfhdDataList.isEmpty())
         	   sb.append('\n');
            
            recno = recno + 1;
            
            if (recno >= maxrec || ! mfhdIds.hasNext() ) {         
                try {                   
                    saveMfhdMrc(sb.toString(), seqno, mfhdDestDir);
                } catch (Exception e) {
                    throw new Exception("Problem saving MFHD MARC to a WEBDAV file. ", e);
                }  
                seqno = seqno + 1;
                recno = 0; 
                sb = new StringBuffer();                             
            }                            
        }

    }


    /**
	 * Get the MARC for each BIB ID, concatenate bib data to create MARC
	 * files. Only put 10000 MARC records in a file.
	 */
	private void saveBIBsToMARC(Set<String> updatedBibIds, String bibDestDir) throws Exception {
        int recno = 0;
        int maxrec = 10000;
        int seqno = 1;
        StringBuffer sb = new StringBuffer();
        
        Iterator<String> bibIds = updatedBibIds.iterator();
        while( bibIds.hasNext()){
            String bibid  = bibIds.next();
            
            List<BibData> bibDataList;
            try {
               bibDataList = getCatalogService().getBibData(bibid);
            } catch (Exception e) { 
                throw new Exception("Could not get MARC for BIB ID " + bibid, e);
            } 
               
           for (BibData bibData : bibDataList) { 
               sb.append(bibData.getRecord()); 
           }
           /* Inserting a carriage return after each MARC record in the file.
            * This is not valid in a technically correct MARC "database" file, but
            * is supported by org.marc4j.MarcPermissiveStreamReader. If we ever stop using this
            * library, we may need to remove this. For now, it simplifies pulling problem
            * records from the MARC "database".
            */
           if (! bibDataList.isEmpty())
        	   sb.append('\n');
           
           recno = recno + 1;
           if (recno >= maxrec || ! bibIds.hasNext() ) {
               try{
                   saveBibMrc(sb.toString(), seqno, bibDestDir);
               } catch (Exception e) {
                   throw new Exception("Problem saving BIB MARC to a WEBDAV file. ", e);
               }
               recno = 0;
               seqno = seqno + 1;
               sb = new StringBuffer();
           }                           
        }                               
    }


    /**
	 * Gets the MFHD IDs related to all the BIB IDs in bibIds 
	 * @throws Exception 
	 */
	private Set<String> getHoldingsForBibs( Set<String> bibIds) throws Exception {	    	    
        Set<String> newMfhdIdSet = new HashSet<String>();        
        for (String bibid : bibIds) {
            try {
                newMfhdIdSet.addAll( getCatalogService().getMfhdIdsByBibId(bibid) );                                    
            } catch (Exception e) {
                throw new Exception("Could not get the MFHD IDs for BIB ID " + bibid, e);
            } 
        }         
        return newMfhdIdSet;
	}	


    /**
	 * Gets the list of BIB IDs that have deleted MFHDs. This list
	 * was generated in step 2.
	 * @throws Exception 
	 * 
	 */
	private List<String> getBibIdsWithDeletedMfhd( VoyagerToSolrConfiguration config, String today ) throws Exception {
        
        String tmpFilePath = config.getTmpDir() +"/"+ "bibListForUpdate-"+ today +".txt";;
        
        String fileName = config.getWebdavBaseUrl() + "/" + config.getDailyBibUpdates() + "/"
                + "bibListForUpdate-"+ today + ".txt";
        System.out.println("Reading BIB ID with modified MHFDs from " + fileName );
        
        List<String> bibListForUpdateList;
        File localTmpBibListForUpdateFile = null;
        try {
            localTmpBibListForUpdateFile = getDavService().getFile(fileName, tmpFilePath);
            bibListForUpdateList = FileUtils.readLines(localTmpBibListForUpdateFile);
        } catch (Exception e1) {
            throw new Exception("Failed reading: "+ fileName, e1);            
        } finally {
            if( localTmpBibListForUpdateFile != null)
                localTmpBibListForUpdateFile.delete();  
        }
        return bibListForUpdateList;
    }


    /**
	 * Gets the list of BIB IDs that are new or newly unsuppressed (or otherwise missing
	 * from the index). This list was generated in step 2.
	 * @throws Exception 
	 * 
	 */
	private List<String> getBibIdsToAdd( VoyagerToSolrConfiguration config, String today ) throws Exception {
        
        String tmpFilePath = config.getTmpDir() +"/"+ "bibListToAdd-"+ today +".txt";;
        
        String fileName = config.getWebdavBaseUrl() + "/" + config.getDailyBibAdds() + "/"
                + "bibListToAdd-"+ today + ".txt";
        System.out.println("Reading BIB ID needed to add to Voyager from " + fileName );
        
        List<String> bibListForAddList = new ArrayList<String>();
        File localTmpBibListForAddFile = null;
        try {
            localTmpBibListForAddFile = getDavService().getFile(fileName, tmpFilePath);
            if (localTmpBibListForAddFile  != null)	
            	bibListForAddList.addAll( FileUtils.readLines(localTmpBibListForAddFile) );
        } catch (Exception e1) {
            throw new Exception("Failed reading: "+ fileName, e1);            
        } finally {
            if( localTmpBibListForAddFile != null)
                localTmpBibListForAddFile.delete();  
        }
        return bibListForAddList;
    }


    /** 
     * @param fromDate in format yyyy-MM-dd HH:mm:ss
     * @param toDate in format yyyy-MM-dd HH:mm:ss
     */
	private Set<String> getUpdatedMfhdIdsFromCatalog(String fromDate, String toDate) 
	        throws Exception {
	    List<String> mfhdIdList;
	    try {
            System.out.println("Getting recently updated MFHD IDs from Catalog");
            mfhdIdList = getCatalogService().getUpdatedMfhdIdsUsingDateRange(fromDate, toDate);
            System.out.println("MfhdIDList size: " + mfhdIdList.size());
        } catch (Exception e) {
            throw new Exception("Problem while attempting to get the updated "
                    + "MFHD IDs from the Catalog",e);
        }
        
	    return new HashSet<String>(mfhdIdList);                
    }


	/** 
	 * @param fromDate in format yyyy-MM-dd HH:mm:ss
	 * @param toDate in format yyyy-MM-dd HH:mm:ss
	 */
    private Set<String> getUpdatedBibIdsFromCatalog(String fromDate, String toDate) 
            throws Exception {
        
        List<String> bibIdList = null;        
        try{
            System.out.println("Getting recently updated BIB IDs from Catalog");
            bibIdList = getCatalogService().getUpdatedBibIdsUsingDateRange(fromDate, toDate);
            System.out.println("BibIDList size: "+ bibIdList.size());
        } catch (Exception e) {
            throw new Exception("Problem while attempting to get the updated "
                    + "BIB IDs from the Catalog",e);
        }
        return new HashSet<String>(bibIdList);
    }


    public void saveBibMrc(String mrc, int seqno, String destDir)
			throws Exception {
		Calendar now = Calendar.getInstance();
		String url = destDir + "/bib.update." + getDateString(now) + "."+ seqno +".mrc";
		System.out.println("Saving BIB mrc to "+ url);
		try { 
			InputStream isr = IOUtils.toInputStream(mrc, "UTF-8");
			getDavService().saveFile(url, isr);

		} catch (UnsupportedEncodingException ex) {
			throw ex;
		} catch (Exception ex) {
			throw ex;
		}
	}
	
	public void saveMfhdMrc(String mrc, int seqno, String destDir)	throws Exception {
		Calendar now = Calendar.getInstance();
		String url = destDir + "/mfhd.update." + getDateString(now) + "."+ seqno +".mrc";
		System.out.println("Saving MFHD mrc to: "+ url);
		try {
			InputStream isr = IOUtils.toInputStream(mrc, "UTF-8");
			getDavService().saveFile(url, isr);

		} catch (UnsupportedEncodingException ex) {
			throw ex;
		} catch (Exception ex) {
			throw ex;
		}
	}
       
   
   /**
    * @param str
    * @return
    * @throws UnsupportedEncodingException
    */
   protected InputStream stringToInputStream(String str) throws UnsupportedEncodingException {
      byte[] bytes = str.getBytes("UTF-8");
      return new ByteArrayInputStream(bytes);	
   }
   
   /**
    * @return
    */
   protected String midnightThisMorning() {
	   Calendar today = Calendar.getInstance();
	   today.set(Calendar.HOUR_OF_DAY, 0);
	   today.set(Calendar.MINUTE, 0);
	   today.set(Calendar.SECOND, 0);
	   today.set(Calendar.MILLISECOND, 0); 
	   return getDateTimeString(today);
   }
   
   protected String daysEarlier(Integer noDays) {
	   Calendar date = Calendar.getInstance();
	   date.set(Calendar.HOUR_OF_DAY, 0);
	   date.set(Calendar.MINUTE, 0);
	   date.set(Calendar.SECOND, 0);
	   date.set(Calendar.MILLISECOND, 0);
	   date.add(Calendar.DAY_OF_MONTH, - noDays);
	   return getDateTimeString(date);
   }
   
   protected String getDateTimeString(Calendar cal) {
	   SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); 
	   String ds = df.format(cal.getTime());
	   return ds;
   } 
   
   protected String getDateString(Calendar cal) {
	   SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd"); 
	   String ds = df.format(cal.getTime());
	   return ds;
   }
       
}
