package edu.cornell.library.integration;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.apache.commons.io.IOUtils;

import edu.cornell.library.integration.bo.BibData;
import edu.cornell.library.integration.bo.MfhdData;
import edu.cornell.library.integration.ilcommons.configuration.SolrBuildConfig;
import edu.cornell.library.integration.ilcommons.service.DavServiceFactory;
import edu.cornell.library.integration.utilities.DaSolrUtilities.CurrentDBTable;

import static edu.cornell.library.integration.ilcommons.configuration.SolrBuildConfig.getRequiredArgsForWebdav;

/**
 * This gets a list of BIB and MFHD records updates from the Voyager database for a
 * given period of time and then saves the MARC for these records to a WEBDAV directory.  
 * 
 * This list is combined with the list of BIB records that have had their MHFD 
 * records deleted which is generated by IdentifyDeletedRecords.
 * 
 * Once the list of the IDs of BIB and MFHD records that are needed is gathered,
 * the Voyager database is queries to get the MARC.  That data is saved to a 
 * sequence of files.
 */
public class GetCombinedUpdatesMrc extends VoyagerToSolrStep {
   
   /**
    * default constructor
    */
   public GetCombinedUpdatesMrc() { 
       
   }     

   /**
    * Main is called with the normal VoyagerToSolrConfiguration args.
    */
   public static void main(String[] args) throws Exception {                
     GetCombinedUpdatesMrc app = new GetCombinedUpdatesMrc();
     List<String> requiredArgs = SolrBuildConfig.getRequiredArgsForDB("Current");
     requiredArgs.addAll(SolrBuildConfig.getRequiredArgsForDB("Voyager"));
     requiredArgs.addAll(getRequiredArgsForWebdav());
     requiredArgs.add("dailyMrcDir");
     requiredArgs.add("dailyMfhdDir");
     requiredArgs.add("dailyBibUpdates");
     requiredArgs.add("dailyBibAdds");
     
     app.getCombinedUpatedsAndSaveAsMARC( SolrBuildConfig.loadConfig(args, requiredArgs) );     
   }
   
   private Connection current;
   
	private void getCombinedUpatedsAndSaveAsMARC(SolrBuildConfig config) 
	        throws Exception{

		setDavService(DavServiceFactory.getDavService( config ));

        Set<Integer> updatedBibIds = new HashSet<Integer>();

		String date =  getDateString(Calendar.getInstance());
		Set<Integer> bibListForUpdate = getUpdatedBibs( config, date );
	    System.out.println("bibListForUpdate: " + bibListForUpdate.size() );
	    updatedBibIds.addAll(bibListForUpdate);
		Set<Integer> bibListForAdd = getBibIdsToAdd( config, date );
	    System.out.println("bibListForAdd: " + bibListForAdd.size() );
	    updatedBibIds.addAll( bibListForAdd );
	    current = config.getDatabaseConnection("Current");
    	PreparedStatement pstmt = current.prepareStatement(
    			"SELECT * FROM "+CurrentDBTable.BIB_VOY.toString()+" WHERE bib_id = ?");
	    Set<Integer> suppressedBibs = checkForSuppressedRecords(pstmt, updatedBibIds);
	    pstmt.close();
	    if ( ! suppressedBibs.isEmpty()) {
	    	System.out.println("suppressed bibs eliminated from list: "+suppressedBibs.size());
	    	updatedBibIds.removeAll(suppressedBibs);
	    }
	     	    
	    // Get MFHD IDs for all the BIB IDs
		System.out.println("Identifying holdings ids");
		Set<Integer> updatedMfhdIds =  getHoldingsForBibs( current, updatedBibIds );
    	pstmt = current.prepareStatement(
    			"SELECT * FROM "+CurrentDBTable.MFHD_VOY.toString()+" WHERE mfhd_id = ?");
	    Set<Integer> suppressedMfhds = checkForSuppressedRecords(pstmt, updatedMfhdIds);
	    pstmt.close();
	    if ( ! suppressedMfhds.isEmpty()) {
	    	updatedMfhdIds.removeAll(suppressedMfhds);
	    }
		
		System.out.println("Total BibIDList: " + updatedBibIds.size());
		System.out.println("Total MfhdIDList: " + updatedMfhdIds.size());

		Connection voyager = config.getDatabaseConnection("Voyager");
		saveBIBsToMARC(  voyager, updatedBibIds , config.getWebdavBaseUrl() + "/" + config.getDailyMrcDir() );
		saveMFHDsToMARC( voyager, updatedMfhdIds, config.getWebdavBaseUrl() + "/" + config.getDailyMfhdDir() );
		voyager.close();
	}


    private Set<Integer> checkForSuppressedRecords(PreparedStatement pstmt, Set<Integer> updatedIds) throws SQLException {
    	Set<Integer> suppressed = new HashSet<Integer>();
    	for (Integer id : updatedIds) {
    		pstmt.setInt(1, id);
    		ResultSet rs = pstmt.executeQuery();
    		boolean isSuppressed = true;
    		while (rs.next())
    			isSuppressed = false;
    		rs.close();
    		if (isSuppressed)
    			suppressed.add(id);
    	}
    	return suppressed;
	}

	/**
     * Get the MARC for each MFHD ID and concatenate data to create MARC files. 
     * Only put 10000 MARC records in a file.
     */
	private void saveMFHDsToMARC(Connection voyager, Set<Integer> updatedMfhdIds, String mfhdDestDir) throws Exception {
	    int recno = 0;
        int maxrec = 10000;
        int seqno = 1;
        StringBuffer sb = new StringBuffer();

        PreparedStatement mfhdStmt = voyager.prepareStatement(
        		"SELECT * FROM MFHD_DATA WHERE MFHD_DATA.MFHD_ID = ? ORDER BY MFHD_DATA.SEQNUM");

        Iterator<Integer> mfhdIds = updatedMfhdIds.iterator();
        while( mfhdIds.hasNext() ){
        	Integer mfhdid = mfhdIds.next();

            List<MfhdData> mfhdDataList = new ArrayList<MfhdData>();
            try {
            	mfhdStmt.setInt(1,mfhdid);
            	ResultSet rs = mfhdStmt.executeQuery();
            	while (rs.next()) {
	                MfhdData mfhdData = new MfhdData(); 
	                mfhdData.setMfhdId(rs.getString("MFHD_ID"));
	                mfhdData.setSeqnum(rs.getString("SEQNUM"));
	                mfhdData.setRecord(new String(rs.getBytes("RECORD_SEGMENT"), StandardCharsets.UTF_8));
	                mfhdDataList.add(mfhdData);
            	}
            	rs.close();
            } catch (Exception e) { 
                throw new Exception("Could not get MARC for MFHD ID " + mfhdid, e );
            } 
            
            for (MfhdData mfhdData : mfhdDataList) { 
                sb.append(mfhdData.getRecord()); 
            }
            /* Inserting a carriage return after each MARC record in the file.
             * This is not valid in a technically correct MARC "database" file, but
             * is supported by org.marc4j.MarcPermissiveStreamReader. If we ever stop using this
             * library, we may need to remove this. For now, it simplifies pulling problem
             * records from the MARC "database".
             */
            if (! mfhdDataList.isEmpty())
         	   sb.append('\n');
            
            recno = recno + 1;
            
            if (recno >= maxrec || ! mfhdIds.hasNext() ) {         
                try {                   
                    saveMfhdMrc(sb.toString(), seqno, mfhdDestDir);
                } catch (Exception e) {
                    throw new Exception("Problem saving MFHD MARC to a WEBDAV file. ", e);
                }  
                seqno = seqno + 1;
                recno = 0; 
                sb = new StringBuffer();                             
            }                            
        }
        mfhdStmt.close();
    }


    /**
	 * Get the MARC for each BIB ID, concatenate bib data to create MARC
	 * files. Only put 10000 MARC records in a file.
	 */
	private void saveBIBsToMARC(Connection voyager, Set<Integer> updatedBibIds, String bibDestDir) throws Exception {
        int recno = 0;
        int maxrec = 10000;
        int seqno = 1;
        StringBuffer sb = new StringBuffer();

        PreparedStatement bibStmt = voyager.prepareStatement(
        		"SELECT * FROM BIB_DATA WHERE BIB_DATA.BIB_ID = ? ORDER BY BIB_DATA.SEQNUM");

        Iterator<Integer> bibIds = updatedBibIds.iterator();
        while( bibIds.hasNext()){
        	Integer bibid  = bibIds.next();

            List<BibData> bibDataList = new ArrayList<BibData>();
            try {
            	bibStmt.setInt(1, bibid);
            	ResultSet rs = bibStmt.executeQuery();
            	while (rs.next()) {
	                BibData bibData = new BibData(); 
	                bibData.setBibId(rs.getString("BIB_ID"));
	                bibData.setSeqnum(rs.getString("SEQNUM"));
	                bibData.setRecord(new String(rs.getBytes("RECORD_SEGMENT"), StandardCharsets.UTF_8));
	                bibDataList.add(bibData);
            	}
            	rs.close();
            } catch (Exception e) {
                throw new Exception("Could not get MARC for BIB ID " + bibid, e);
            }

            for (BibData bibData : bibDataList) { 
            	sb.append(bibData.getRecord()); 
            }
            /* Inserting a carriage return after each MARC record in the file.
             * This is not valid in a technically correct MARC "database" file, but
             * is supported by org.marc4j.MarcPermissiveStreamReader. If we ever stop using this
             * library, we may need to remove this. For now, it simplifies pulling problem
             * records from the MARC "database".
             */
            if (! bibDataList.isEmpty())
            	sb.append('\n');

            recno = recno + 1;
            if (recno >= maxrec || ! bibIds.hasNext() ) {
            	try{
            		saveBibMrc(sb.toString(), seqno, bibDestDir);
            	} catch (Exception e) {
            		throw new Exception("Problem saving BIB MARC to a WEBDAV file. ", e);
            	}
            	recno = 0;
            	seqno = seqno + 1;
            	sb = new StringBuffer();
            }
        }
        bibStmt.close();
    }


    /**
	 * Gets the MFHD IDs related to all the BIB IDs in bibIds 
	 * @throws Exception 
	 */
	private Set<Integer> getHoldingsForBibs( Connection current, Set<Integer> bibIds) throws Exception {
		PreparedStatement holdingsForBibsStmt = current.prepareStatement(
				"SELECT mfhd_id FROM "+CurrentDBTable.MFHD_VOY.toString()+" WHERE bib_id = ?");
        Set<Integer> newMfhdIdSet = new HashSet<Integer>();        
        for (Integer bibid : bibIds) {
        	holdingsForBibsStmt.setInt(1,bibid);
        	ResultSet rs = holdingsForBibsStmt.executeQuery();
        	while (rs.next())
        		newMfhdIdSet.add(rs.getInt(1));
        	rs.close();
        }
        holdingsForBibsStmt.close();
        return newMfhdIdSet;
	}	


    /**
	 * Gets the list of BIB IDs require updating in Solr.
	 * @throws Exception 
	 * 
	 */
	private Set<Integer> getUpdatedBibs( SolrBuildConfig config, String today ) throws Exception {

        List<String> updateFiles = getDavService().getFileUrlList(
        		config.getWebdavBaseUrl() + "/" + config.getDailyBibUpdates() + "/");
        Set<Integer> updatedBibs = new HashSet<Integer>();
        for (String url : updateFiles) {
    	    final Path tempPath = Files.createTempFile("getCombinedUpdatesMrc-", ".txt");
    		tempPath.toFile().deleteOnExit();
            File localTmpFile = getDavService().getFile(url, tempPath.toString());
            try (BufferedReader br = new BufferedReader(new FileReader(localTmpFile))) {
                String line;
                while ((line = br.readLine()) != null) {
                	updatedBibs.add(Integer.valueOf(line));
                }
            }
            localTmpFile.delete();
        }
        return updatedBibs;
    }


    /**
	 * Gets the list of BIB IDs that are new or newly unsuppressed (or otherwise missing
	 * from the index). This list was generated in step 2.
	 * @throws Exception 
	 * 
	 */
	private Set<Integer> getBibIdsToAdd( SolrBuildConfig config, String today ) throws Exception {
        
        List<String> addFiles = getDavService().getFileUrlList(
        		config.getWebdavBaseUrl() + "/" + config.getDailyBibAdds() + "/");
        Set<Integer> addedBibs = new HashSet<Integer>();
        for (String url : addFiles) {
    	    final Path tempPath = Files.createTempFile("getCombinedUpdatesMrc-", ".txt");
    		tempPath.toFile().deleteOnExit();
            File localTmpFile = getDavService().getFile(url, tempPath.toString());
            try (BufferedReader br = new BufferedReader(new FileReader(localTmpFile))) {
            	String line;
                while ((line = br.readLine()) != null) {
                	addedBibs.add(Integer.valueOf(line));
                }
            }
            localTmpFile.delete();
        }
        return addedBibs;
    }

    private void saveBibMrc(String mrc, int seqno, String destDir)
			throws Exception {
		Calendar now = Calendar.getInstance();
		String url = destDir + "/bib.update." + getDateString(now) + "."+ seqno +".mrc";
		System.out.println("Saving BIB mrc to "+ url);
		try { 
			InputStream isr = IOUtils.toInputStream(mrc, "UTF-8");
			getDavService().saveFile(url, isr);

		} catch (UnsupportedEncodingException ex) {
			throw ex;
		} catch (Exception ex) {
			throw ex;
		}
	}
	
	private void saveMfhdMrc(String mrc, int seqno, String destDir)	throws Exception {
		Calendar now = Calendar.getInstance();
		String url = destDir + "/mfhd.update." + getDateString(now) + "."+ seqno +".mrc";
		System.out.println("Saving MFHD mrc to: "+ url);
		try {
			InputStream isr = IOUtils.toInputStream(mrc, "UTF-8");
			getDavService().saveFile(url, isr);

		} catch (UnsupportedEncodingException ex) {
			throw ex;
		} catch (Exception ex) {
			throw ex;
		}
	}
   
   private String getDateString(Calendar cal) {
	   SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd"); 
	   String ds = df.format(cal.getTime());
	   return ds;
   }
       
}
