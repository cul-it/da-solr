package edu.cornell.library.integration.indexer;

import java.io.IOException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import edu.cornell.library.integration.ilcommons.configuration.SolrBuildConfig;
import edu.cornell.library.integration.indexer.utilities.Generator;
import edu.cornell.library.integration.marc.ControlField;
import edu.cornell.library.integration.marc.DataField;
import edu.cornell.library.integration.marc.MarcRecord;

/**
 * Generate Solr fields based on a MARC bibliographic record with optional holdings, using a configured
 * set of field generators. Requires a SolrBuildConfig containing the necessary database
 * connection information to push the results to the configured DB.
 * For example:<br/><br/>
 * <pre> MarcRecord rec = ...;
 * SolrBuildConfig config = ...;
 * GenerateSolrFields gen = new GenerateSolrFields(EnumSet.of(
 *		Generator.AUTHORTITLE, Generator.SUBJECT));
 * gen.generateSolr(rec, config);</pre> *
 */
public class GenerateSolrFields {

	// INSTANCE VARIABLES
	private final EnumSet<Generator> activeGenerators; // provided to constructor
	private final String tableName; // provided to constructor
	private final Map<String,List<Generator>> fieldsSupported; // generated by constructor

	// CONSTRUCTOR
	public GenerateSolrFields( EnumSet<Generator> activeGenerators, String tableName ) {
		this.activeGenerators = activeGenerators;
		this.tableName = tableName;
		this.fieldsSupported = constructFieldsSupported( activeGenerators );
	}

	// BEGIN INSTANCE METHODS

	public int generateSolr( MarcRecord rec, SolrBuildConfig config ) throws SQLException, ClassNotFoundException {

		Map<Generator,MarcRecord> recordChunks = createMARCChunks(rec,activeGenerators,this.fieldsSupported);
		Map<Generator,BibGeneratorData> originalValues = pullPreviousFieldDataFromDB(
				activeGenerators,tableName,rec.id,config);
		LocalDateTime now = LocalDateTime.now();
		List<BibGeneratorData> newValues = recordChunks.entrySet()
			.parallelStream()
			.map(entry -> processRecordChunkWithGenerator(
					entry.getKey(), entry.getValue(),originalValues.get(entry.getKey()), now, config))
			.collect(Collectors.toList());

		int sectionsChanged = 0, sectionsGenerated = 0;
		for (BibGeneratorData newGeneratorData : newValues) {
			if (newGeneratorData == null) continue;
			Generator gen = newGeneratorData.gen;
			System.out.println("Generator: "+gen+
					"; MARC Segment: "+newGeneratorData.marcStatus+
					"; Solr fields: "+newGeneratorData.solrStatus);
			if (newGeneratorData.solrStatus.equals(Status.NEW) ||
					newGeneratorData.solrStatus.equals(Status.CHANGED))
				sectionsChanged++;
			if ( ! newGeneratorData.solrStatus.equals(Status.UNGENERATED))
				sectionsGenerated++;
		}

		System.out.println(rec.id+": "+sectionsGenerated+" generated, "+sectionsChanged+" sections changed.");
		if (sectionsGenerated > 0)
			pushNewFieldDataToDB(activeGenerators,newValues,tableName,rec.id,config);
		return sectionsChanged;
	}

	/**
	 * Create a table with the tableName specified in the constructor, in the Current database
	 * accessed through the SolrBuildConfig.
	 * @param config
	 * @throws ClassNotFoundException
	 * @throws SQLException
	 */
	public void setUpDatabase( SolrBuildConfig config ) throws ClassNotFoundException, SQLException {

		StringBuilder sbTableCreate = new StringBuilder();
		sbTableCreate.append("CREATE TABLE IF NOT EXISTS ").append(this.tableName).append(" (\n");
		sbTableCreate.append("bib_id  INT(10) UNSIGNED NOT NULL PRIMARY KEY,\n");
		for ( Generator gen : activeGenerators ) {
			String genName = gen.name().toLowerCase();
			sbTableCreate.append(genName).append("_marc_segment          TEXT DEFAULT NULL,\n");
			sbTableCreate.append(genName).append("_solr_fields           LONGTEXT DEFAULT NULL,\n");
			sbTableCreate.append(genName).append("_solr_fields_gen_date  TIMESTAMP NULL,\n");
		}
		sbTableCreate.setCharAt(sbTableCreate.length()-2, ')');
		try ( Connection conn = config.getDatabaseConnection("Current");
				Statement stmt = conn.createStatement()) {
			stmt.execute(sbTableCreate.toString());
		}

	}

	// BEGIN PRIVATE RESOURCES

	private static void pushNewFieldDataToDB(
			EnumSet<Generator> activeGenerators,
			List<BibGeneratorData> newValues,
			String tableName,
			String bib_id,
			SolrBuildConfig config) throws ClassNotFoundException, SQLException {

		if (sql == null) {
			StringBuilder sbSql = new StringBuilder();
			sbSql.append("REPLACE INTO ").append(tableName).append(" (");
			sbSql.append("bib_id,\n");
			for (Generator gen : activeGenerators) {
				String genName = gen.name().toLowerCase();
				sbSql.append(genName).append("_marc_segment,\n");
				sbSql.append(genName).append("_solr_fields,\n");
				sbSql.append(genName).append("_solr_fields_gen_date,\n");		
			}
			sbSql.setCharAt(sbSql.length()-2, ')');
			sbSql.append("VALUES ( ");
			int questionMarksNeeded = activeGenerators.size()*3+1;
			for (int i = 1 ; i <= questionMarksNeeded; i++) sbSql.append("?,");
			sbSql.setCharAt(sbSql.length()-1, ')');
			sql = sbSql.toString();
		}

		Map<Generator,BibGeneratorData> newValuesMap = new HashMap<>();
		for (BibGeneratorData data : newValues) newValuesMap.put(data.getGenerator(), data);
		try ( Connection conn = config.getDatabaseConnection("Current");
				PreparedStatement pstmt = conn.prepareStatement(sql)) {
			int parameterIndex = 1;
			pstmt.setString(parameterIndex++, bib_id);
			for (Generator gen : activeGenerators) {
				BibGeneratorData data = newValuesMap.get(gen);
				pstmt.setString(parameterIndex++, data.marcSegment);
				pstmt.setString(parameterIndex++, data.solrSegment);
				pstmt.setTimestamp(parameterIndex++, data.solrGenDate);
			}
			pstmt.executeUpdate();
		}
		
	}
	static String sql = null;

	private static Map<Generator, BibGeneratorData> pullPreviousFieldDataFromDB
	(EnumSet<Generator> activeGenerators,String tableName, String bib_id, SolrBuildConfig config)
			throws SQLException, ClassNotFoundException {

		Map<Generator,BibGeneratorData> allData = new HashMap<>();
		try ( Connection conn = config.getDatabaseConnection("Current");
				PreparedStatement pstmt = conn.prepareStatement("SELECT * FROM "+tableName+" WHERE bib_id = ?") ){
			pstmt.setInt(1, Integer.valueOf(bib_id));
			try ( ResultSet rs = pstmt.executeQuery() ) {
				while (rs.next()) {
					for ( Generator gen : activeGenerators) {
						String genName = gen.name().toLowerCase();
						BibGeneratorData d = new BibGeneratorData(
								rs.getString(genName+"_marc_segment"),
								rs.getString(genName+"_solr_fields"),
								rs.getTimestamp(genName+"_solr_fields_gen_date"));
						allData.put(gen,d);
					}
					return allData;
				}
			}
		}

		// No pre-existing data exists
		BibGeneratorData d = new BibGeneratorData( null, null, null );
		for ( Generator gen : activeGenerators )
			allData.put(gen,d);
		return allData;
	}

	private static Map<String, List<Generator>> constructFieldsSupported(EnumSet<Generator> activeGenerators) {
		Map<String,List<Generator>> fieldsSupported = new HashMap<>();
		for (Generator gen : activeGenerators) {
			List<String> classFieldsSupported = gen.getInstance().getHandledFields();
			for (String field : classFieldsSupported) {
				if ( ! fieldsSupported.containsKey(field) )
					fieldsSupported.put(field, new ArrayList<Generator>());
				fieldsSupported.get(field).add(gen);
			}
		}
		return fieldsSupported;
	}

	private static BibGeneratorData processRecordChunkWithGenerator(
			Generator gen,MarcRecord recChunk, BibGeneratorData origData, LocalDateTime now, SolrBuildConfig config)
			/*throws ClassNotFoundException, SQLException, IOException */{

		String marcSegment = recChunk.toString();
		Status marcStatus = (origData.marcSegment == null) ? Status.NEW :
			(marcSegment.equals(origData.marcSegment)) ? Status.UNCHANGED : Status.CHANGED;

		if (marcStatus.equals(Status.UNCHANGED)) {
			if (Timestamp.valueOf(now.minus(gen.getInstance().resultsShelfLife())).after(origData.solrGenDate))
				marcStatus = Status.STALE;
			else {
				origData.marcStatus = Status.UNCHANGED;
				origData.solrStatus = Status.UNGENERATED;
				origData.gen = gen;
				return origData;
			}
		}

		String solrFields;
		try {
			solrFields = gen.getInstance().generateSolrFields(recChunk,config).toString();
		} catch (ClassNotFoundException | SQLException | IOException e) {
			System.out.println("Generator "+gen+" failed on bib"+recChunk.id+"\n");
			e.printStackTrace();
			return null;
		}
		BibGeneratorData newData = new BibGeneratorData( marcSegment, solrFields, Timestamp.valueOf(now) );
		newData.marcStatus = marcStatus;
		newData.solrStatus = (origData.solrSegment == null) ? Status.NEW :
			( solrFields.equals(origData.solrSegment) ) ? Status.UNCHANGED : Status.CHANGED;
		newData.gen = gen;
		return newData;
	}

	private static Map<Generator,MarcRecord> createMARCChunks(
			MarcRecord rec, EnumSet<Generator> activeGenerators, Map<String,List<Generator>> fieldsSupported) {
		Map<Generator,MarcRecord> recordChunks = new HashMap<>();

		for (Generator gen : activeGenerators) {
			recordChunks.put(gen, new MarcRecord( MarcRecord.RecordType.BIBLIOGRAPHIC ));
			recordChunks.get(gen).id = rec.id;
			recordChunks.get(gen).modifiedDate = rec.modifiedDate;
		}

		if (fieldsSupported.containsKey("leader"))
			for (Generator supportingClass : fieldsSupported.get("leader"))
				recordChunks.get(supportingClass).leader = rec.leader;

		for (ControlField f : rec.controlFields)
			if (fieldsSupported.containsKey(f.tag))
				for( Generator supportingClass : fieldsSupported.get(f.tag))
					recordChunks.get(supportingClass).controlFields.add(f);

		for (DataField f : rec.dataFields)
			if (fieldsSupported.containsKey(f.tag))
				for( Generator supportingClass : fieldsSupported.get(f.tag))
					recordChunks.get(supportingClass).dataFields.add(f);
			else
				System.out.println( "Unrecognized field "+f.tag+" in record "+rec.id );

		if (fieldsSupported.containsKey("holdings"))
			for (Generator supportingClass : fieldsSupported.get("holdings"))
				recordChunks.get(supportingClass).holdings = rec.holdings;

		return recordChunks;
	}

	private static class BibGeneratorData {
		final String marcSegment;
		final String solrSegment;
		final Timestamp solrGenDate;
		Status marcStatus = null;
		Status solrStatus = null;
		Generator gen = null;
		public BibGeneratorData( String marcSegment, String solrSegment, Timestamp solrGenDate) {
			this.marcSegment = marcSegment;
			this.solrSegment = solrSegment;
			this.solrGenDate = solrGenDate;
		}
		public Generator getGenerator() { return this.gen; }
	}

	private enum Status { UNGENERATED,NEW,CHANGED,UNCHANGED,STALE; }
}
