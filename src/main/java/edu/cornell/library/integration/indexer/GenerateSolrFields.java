package edu.cornell.library.integration.indexer;

import java.io.IOException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import edu.cornell.library.integration.ilcommons.configuration.SolrBuildConfig;
import edu.cornell.library.integration.indexer.solrFieldGen.ResultSetUtilities.SolrFields;
import edu.cornell.library.integration.indexer.utilities.Generator;
import edu.cornell.library.integration.marc.ControlField;
import edu.cornell.library.integration.marc.DataField;
import edu.cornell.library.integration.marc.MarcRecord;

/**
 * Generate Solr fields based on a MARC bibliographic record with optional holdings, using a configured
 * set of field generators. Requires a SolrBuildConfig containing the necessary database
 * connection information to push the results to the configured DB.
 * For example:<br/><br/>
 * <pre> MarcRecord rec = ...;
 * SolrBuildConfig config = ...;
 * GenerateSolrFields gen = new GenerateSolrFields(EnumSet.of(
 *		Generator.AUTHORTITLE, Generator.SUBJECT));
 * gen.generateSolr(rec, config);</pre> *
 */
public class GenerateSolrFields {

	// INSTANCE VARIABLES
	private final EnumSet<Generator> activeGenerators; // provided to constructor
	private final Map<String,List<Generator>> fieldsSupported; // generated by constructor
	private final Map<Generator,Map<String,String>> generatorSpecificSQLQueries; // generated by constructor

	// CONSTRUCTOR
	public GenerateSolrFields( EnumSet<Generator> activeGenerators ) {
		this.activeGenerators = activeGenerators;
		this.fieldsSupported = constructFieldsSupported( activeGenerators );
		this.generatorSpecificSQLQueries = constructGeneratorSpecificSQLQueries( activeGenerators );
	}

	// BEGIN INSTANCE METHODS

	public Integer generateSolr( MarcRecord rec, SolrBuildConfig config )
			throws ClassNotFoundException, SQLException, IOException {
		Map<Generator,MarcRecord> recordChunks = createMARCChunks(rec,activeGenerators,this.fieldsSupported);
		Integer fieldSectionsChanged = 0;
		for (Entry<Generator,MarcRecord> e : recordChunks.entrySet())
			if ( processRecordChunkWithGenerator(
					e.getKey(),generatorSpecificSQLQueries.get(e.getKey()),e.getValue(),config) )
				fieldSectionsChanged++;
		System.out.println(fieldSectionsChanged+" sections changed.");
		return fieldSectionsChanged;
	}

	public void setUpDatabase( SolrBuildConfig config ) throws ClassNotFoundException, SQLException {

		try ( Connection conn = config.getDatabaseConnection("Current");
				Statement stmt = conn.createStatement()) {
			for ( Generator gen : activeGenerators )
				stmt.executeUpdate(generatorSpecificSQLQueries.get(gen).get("createTableSQL"));
		}
	}

	// BEGIN PRIVATE RESOURCES

	private static Map<String, List<Generator>> constructFieldsSupported(EnumSet<Generator> activeGenerators) {
		Map<String,List<Generator>> fieldsSupported = new HashMap<>();
		for (Generator gen : activeGenerators) {
			List<String> classFieldsSupported = gen.getInstance().getHandledFields();
			for (String field : classFieldsSupported) {
				if ( ! fieldsSupported.containsKey(field) )
					fieldsSupported.put(field, new ArrayList<Generator>());
				fieldsSupported.get(field).add(gen);
			}
		}
		return fieldsSupported;
	}

	private static Map<Generator,Map<String,String>> constructGeneratorSpecificSQLQueries(
			EnumSet<Generator> activeGenerators){
		Map<String,String> queryTemplates = new HashMap<>();
		queryTemplates.put("createTableSQL",
				"CREATE TABLE IF NOT EXISTS $segmentTable ( \n"+
				" bib_id                INT(10) UNSIGNED NOT NULL PRIMARY KEY,\n"+
				" marc_segment          TEXT DEFAULT NULL,\n"+
				" marc_segment_mod_date TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n"+
				" solr_fields           LONGTEXT DEFAULT NULL,\n"+
				" solr_fields_mod_date  TIMESTAMP NULL,\n"+
				" solr_fields_gen_date  TIMESTAMP NULL )");
		queryTemplates.put("solrFieldsQuerySQL",
				"SELECT solr_fields, solr_fields_mod_date FROM $segmentTable WHERE bib_id = ?");
		queryTemplates.put("solrFieldsUpdateSQL",
				"UPDATE $segmentTable "
				+ "SET solr_fields = ?, solr_fields_mod_date = ?, solr_fields_gen_date = ? "
				+ "WHERE bib_id = ?");
		queryTemplates.put("marcSegmentQuerySQL",
				"SELECT marc_segment, (solr_fields_gen_date > ?) AS is_fresh FROM $segmentTable WHERE bib_id = ?");
		queryTemplates.put("marcSegmentInsertSQL",
				"INSERT INTO $segmentTable ( bib_id, marc_segment ) VALUES ( ? , ? )");
		queryTemplates.put("marcSegmentUpdateSQL",
				"UPDATE $segmentTable SET marc_segment =?, marc_segment_mod_date = NOW() WHERE bib_id = ?");

		Map<Generator,Map<String,String>> generatorSpecificSQLQueries = new HashMap<>();
		for (Generator gen : activeGenerators) {
			String dbTable = "solr_seg_"+gen.name().toLowerCase();
			Map<String,String> thisGeneratorSQLQueries = new HashMap<>();
			for (Entry<String,String> e : queryTemplates.entrySet())
				thisGeneratorSQLQueries.put(e.getKey(), e.getValue().replace("$segmentTable", dbTable));
			generatorSpecificSQLQueries.put(gen,thisGeneratorSQLQueries);
		}
		return generatorSpecificSQLQueries;
	}

	private static boolean processRecordChunkWithGenerator(
			Generator gen, Map<String,String> thisGeneratorSQLQueries, MarcRecord rec, SolrBuildConfig config)
			throws ClassNotFoundException, SQLException, IOException {
		Status segStat = checkForMarcSegmentChangeAndUpdateInDB( gen, thisGeneratorSQLQueries, rec, config );
		if (segStat.equals(Status.UNCHANGED)) {
			System.out.println("Generator: "+gen+"; MARC Segment: "+segStat+"; Not generating Solr Fields");
			return false;
		}
		Status fieldsStat = generateSolrFieldsForMARCSegment( gen, thisGeneratorSQLQueries, rec, config );
		System.out.println("Generator: "+gen+"; MARC Segment: "+segStat+"; Solr Fields: "+fieldsStat);
		if ( Status.NEW.equals(fieldsStat) || Status.CHANGED.equals(fieldsStat))
			return true;
		return false;
	}

	private static Status generateSolrFieldsForMARCSegment(
			Generator gen, Map<String,String> thisGeneratorSQLQueries, MarcRecord rec, SolrBuildConfig config)
			throws ClassNotFoundException, SQLException, IOException {

		SolrFields sfs = gen.getInstance().generateSolrFields(rec, config);
		String solrFields = sfs.toString();
		Status stat = null;
		try ( Connection conn = config.getDatabaseConnection("Current") ) {
			Timestamp prevModDate = null;
			try ( PreparedStatement pstmt = conn.prepareStatement( thisGeneratorSQLQueries.get("solrFieldsQuerySQL") )){
				pstmt.setInt(1,Integer.valueOf(rec.id));
				try ( ResultSet rs = pstmt.executeQuery() ) {
					while (rs.next()) {
						prevModDate = rs.getTimestamp(2);
						String prevFields = rs.getString(1);
						if (prevFields == null)
							stat = Status.NEW;
						else if (solrFields.equals(rs.getString(1)))
							stat = Status.UNCHANGED;
						else
							stat = Status.CHANGED;
					}
				}
			}
			try ( PreparedStatement pstmt = conn.prepareStatement(thisGeneratorSQLQueries.get("solrFieldsUpdateSQL") )){
				Timestamp now = new Timestamp( Calendar.getInstance().getTime().getTime() );
				pstmt.setString(    1, solrFields );
				pstmt.setTimestamp( 2, Status.UNCHANGED.equals(stat)?prevModDate:now );
				pstmt.setTimestamp( 3, now);
				pstmt.setInt(       4, Integer.valueOf(rec.id));
				pstmt.executeUpdate();
			}
		}
		return stat;
	}

	private static Status checkForMarcSegmentChangeAndUpdateInDB(
			Generator gen, Map<String,String> thisGeneratorSQLQueries, MarcRecord rec, SolrBuildConfig config)
			throws NumberFormatException, SQLException, ClassNotFoundException {

		try ( Connection conn = config.getDatabaseConnection("Current") ) {
			Status stat = null;
			try ( PreparedStatement pstmt = conn.prepareStatement(
					thisGeneratorSQLQueries.get("marcSegmentQuerySQL"))){
				pstmt.setTimestamp(1,Timestamp.valueOf(LocalDateTime.now().minus(gen.getInstance().resultsShelfLife())));
				pstmt.setInt(2, Integer.valueOf(rec.id));
				try ( ResultSet rs = pstmt.executeQuery() ) {
					while (rs.next()) {
						if ( rs.getString(1).equals(rec.toString()) ) {
							if ( rs.getBoolean(2) == true )
								return Status.UNCHANGED;
							return Status.STALE;
						}
						stat = Status.CHANGED;
					}
				}
			}
			if (stat == null) // Status.NEW
				try ( PreparedStatement pstmt = conn.prepareStatement(
						thisGeneratorSQLQueries.get("marcSegmentInsertSQL")) ){
					pstmt.setInt(1, Integer.valueOf(rec.id));
					pstmt.setString(2, rec.toString());
					pstmt.executeUpdate();
					return Status.NEW;
				}
			if (Status.CHANGED.equals(stat))
				try ( PreparedStatement pstmt = conn.prepareStatement(
						thisGeneratorSQLQueries.get("marcSegmentUpdateSQL")) ){
					pstmt.setString(1, rec.toString());
					pstmt.setInt(2, Integer.valueOf(rec.id));
					pstmt.executeUpdate();
					return stat;
				}
		}
		return null;
	}

	private static Map<Generator,MarcRecord> createMARCChunks(
			MarcRecord rec, EnumSet<Generator> activeGenerators, Map<String,List<Generator>> fieldsSupported) {
		Map<Generator,MarcRecord> recordChunks = new HashMap<>();

		for (Generator gen : activeGenerators) {
			recordChunks.put(gen, new MarcRecord( MarcRecord.RecordType.BIBLIOGRAPHIC ));
			recordChunks.get(gen).id = rec.id;
			recordChunks.get(gen).modifiedDate = rec.modifiedDate;
		}

		if (fieldsSupported.containsKey("leader"))
			for (Generator supportingClass : fieldsSupported.get("leader"))
				recordChunks.get(supportingClass).leader = rec.leader;

		for (ControlField f : rec.controlFields)
			if (fieldsSupported.containsKey(f.tag))
				for( Generator supportingClass : fieldsSupported.get(f.tag))
					recordChunks.get(supportingClass).controlFields.add(f);

		for (DataField f : rec.dataFields)
			if (fieldsSupported.containsKey(f.tag))
				for( Generator supportingClass : fieldsSupported.get(f.tag))
					recordChunks.get(supportingClass).dataFields.add(f);
			else
				System.out.println( "Unrecognized field "+f.tag+" in record "+rec.id );

		if (fieldsSupported.containsKey("holdings"))
			for (Generator supportingClass : fieldsSupported.get("holdings"))
				recordChunks.get(supportingClass).holdings = rec.holdings;

		return recordChunks;
	}

	private enum Status { NEW,CHANGED,UNCHANGED,STALE; }
}
